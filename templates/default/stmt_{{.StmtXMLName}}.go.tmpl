// Auto generated by sqlw-mysql (https://github.com/huangjunwen/sqlw-mysql) default template.
// DON NOT EDIT.

package {{ .PackageName }}

import (
  "fmt"
  "context"
  "text/template"
  "database/sql"
  "bytes"
  "time"

  "github.com/jmoiron/sqlx"
  null "gopkg.in/volatiletech/null.v6"
)

{{ range .Stmts }}

  {{ $stmtName := .StmtName }}
  {{ $type := .StmtType }}
  {{ $args := extractArgsInfo . }}
  {{ $vars := extractVarsInfo . }}
  {{ $wcs := extractWildcardsInfo . }}

  {{ $flagHasWildcard := gt (len $wcs.Wildcards) 0 }}
  {{ $flagSingleWildcard := $wcs.SingleWildcard }}
  {{ $flagUseTemplate := $vars.Has "use_template" }}
  {{ $flagInQuery := $vars.Has "in_query" }}
  {{ $flagReturnOne := eq ($vars.Value "return") "one" }}

  {{ if eq $type "SELECT"}}

    {{ $resultName := ternary ($wcs.Wildcard 0).Table.CamelName (printf "%sResult" $stmtName) $flagSingleWildcard }}

    {{ if not $flagSingleWildcard }}

      // {{ $resultName }} is the result of `{{ $stmtName }}`.
      type {{ $resultName }} struct {
        {{ range $i, $col := .QueryResultCols -}}
          {{ $wc := $wcs.ResultCol2Wildcard $i -}}
          {{ $wcCol := $wcs.ResultCol2WildcardCol $i -}}
          {{ if $wcCol.Valid -}}
            {{ if eq $wcCol.Pos 0 -}}
              {{ $wc.CamelName }} *{{ $wc.Table.CamelName }}
            {{ end -}}
          {{ else -}}
            {{ camelcase $col.Name }} {{ scanType $col }}
          {{ end -}}
        {{ end -}}

        {{ range $wc := $wcs.Wildcards -}}
          nxNull{{ $wc.CamelName }} nxNull{{ $wc.Table.CamelName }}
        {{ end -}}
      }

      func (result *{{ $resultName }}) nxPreScan(dest *[]interface{}) {
        {{ range $i, $col := .QueryResultCols -}}
          {{ $wc := $wcs.ResultCol2Wildcard $i -}}
          {{ $wcCol := $wcs.ResultCol2WildcardCol $i -}}
          {{ if $wcCol.Valid -}}
            {{ if eq $wcCol.Pos 0 -}}
              result.nxNull{{ $wc.CamelName }}.nxPreScan(dest)
            {{ end -}}
          {{ else -}}
            *dest = append(*dest, &result.{{ camelcase $col.Name }})
          {{ end -}}
        {{ end -}}
      }

      func (result *{{ $resultName }}) nxPostScan() error {
        {{ range $wc := $wcs.Wildcards }}
          if err := result.nxNull{{ $wc.CamelName }}.nxPostScan(); err != nil {
            return err
          }
          result.{{ $wc.CamelName }} = result.nxNull{{ $wc.CamelName }}.Ordinary()
        {{ end }}
        return nil
      }

      {{ if and (not $flagReturnOne) $flagHasWildcard }}

        // {{ $resultName }}Slice is slice of {{ $resultName }}.
        type {{ $resultName }}Slice []*{{ $resultName }}

        // nx{{ $resultName }}Slices is slice of {{ $resultName }}Slice.
        type nx{{ $resultName }}Slices []{{ $resultName }}Slice

        func (slice *{{ $resultName }}Slice) nxLen() int {
          return len(*slice)
        }

        func (slice *{{ $resultName }}Slice) nxItem(i int) interface{} {
          return (*slice)[i]
        }

        func (slice *{{ $resultName }}Slice) nxAppend(item interface{}) {
          if item == nil {
            *slice = append(*slice, &{{ $resultName }}{})
          } else {
            *slice = append(*slice, item.(*{{ $resultName }}))
          }
        }

        // One returns a single {{ $resultName }}. It panics if the length of slice is not 1.
        func (slice *{{ $resultName }}Slice) One() *{{ $resultName }} {
          if len(*slice) != 1 {
            panic(fmt.Errorf("{{ $resultName }}Slice.One is called but has %d rows", len(*slice)))
          }
          return (*slice)[0]
        }
  
        {{ range $wc := $wcs.Wildcards }}
          {{ if $wc.Table.Primary.Valid }}
            // Distinct{{ $wc.CamelName }} returns distinct (by primary value) {{ $wc.CamelName }} in the slice.
            func (slice *{{ $resultName }}Slice) Distinct{{ $wc.CamelName }}() []*{{ $wc.Table.CamelName }}{
              trs := {{ $wc.Table.CamelName }}Slice{}
              groupBy(slice, func(item interface{}) TableRowWithPrimary {
                return item.(*{{ $resultName }}).{{ $wc.CamelName }}
              }, &trs, nil)
              return trs
            }

            // GroupBy{{ $wc.CamelName }} groups by {{ $wc.CamelName }} and returns distinct (by primary value) {{ $wc.CamelName }} with
            // their associated sub group of slices.
            func (slice *{{ $resultName }}Slice) GroupBy{{ $wc.CamelName }}() ([]*{{ $wc.Table.CamelName }}, []{{ $resultName }}Slice) {
              trs := {{ $wc.Table.CamelName }}Slice{}
              groups := nx{{ $resultName }}Slices{}
              groupBy(slice, func(item interface{}) TableRowWithPrimary {
                return item.(*{{ $resultName }}).{{ $wc.CamelName }}
              }, &trs, &groups)
              return trs, groups
            }
          {{ end }}
        {{ end }}

        func (slices *nx{{ $resultName }}Slices) nxLen() int {
          return len(*slices)
        }

        func (slices *nx{{ $resultName }}Slices) nxItem(i int) interface{} {
          return &((*slices)[i])
        }

        func (slices *nx{{ $resultName }}Slices) nxAppend(item interface{}) {
          if item == nil {
            *slices = append(*slices, {{ $resultName }}Slice{})
          } else {
            *slices = append(*slices, *(item.(*{{ $resultName }}Slice)))
          }
        }

      {{ end }}

    {{ end }}
      
    /*
{{ $stmtName }} is created from:

  {{ .StmtSrc | replace "\n" "\n  " }}
    */
    func {{ $stmtName }}(ctx context.Context, q Queryer{{ range $args.Args }}, {{ .ArgName }} {{ .ArgType }}{{ end }}) ({{ if $flagReturnOne }}*{{ $resultName }}{{ else if not $flagHasWildcard }}[]*{{ $resultName }}{{ else }}{{ $resultName }}Slice{{ end }}, error) {
      // NOTE: Add a nested block to allow identifier shadowing.
      {
        // Build query.
        query, args, err := nxBuild{{ $stmtName }}Query(map[string]interface{}{
          {{ range $args.Args -}}
            "{{ .ArgName }}": {{ .ArgName }},
          {{ end -}}
        })
        if err != nil {
          return nil, err
        }

        {{ if $flagReturnOne }}
          // Query.
          row := q.QueryRowContext(ctx, query, args...)

          // Fill scan pointers.
          pointers := make([]interface{}, 0, {{ .NumQueryResultCol }})
          result := &{{ $resultName }}{}
          result.nxPreScan(&pointers)

          // Scan.
          err = row.Scan(pointers...)
          if err != nil {
            if err == sql.ErrNoRows {
              return nil, nil
            }
            return nil, err
          }

          // Post scan process.
          if err := result.nxPostScan(); err != nil {
            return nil, err
          }
          return result, nil

        {{ else }} 
          // Query.
          rows, err := q.QueryContext(ctx, query, args...)
          if err != nil {
            return nil, err
          }
          defer rows.Close()

          // Scan.
          results := []*{{ $resultName }}{}
          pointers := make([]interface{}, 0, {{ .NumQueryResultCol }})
          for rows.Next() {
            // Fill scan pointers.
            pointers = pointers[0:0]
            result := &{{ $resultName }}{}
            result.nxPreScan(&pointers)

            // Scan.
            err = rows.Scan(pointers...)
            if err != nil {
              return nil, err
            }

            // Post scan process.
            if err := result.nxPostScan(); err != nil {
              return nil, err
            }
            results = append(results, result)
          }

          if err := rows.Err(); err != nil {
            return nil, err
          }
          return results, nil

        {{ end }} 

      }

    }

  {{ else }}

    /*
{{ $stmtName }} is created from:

  {{ .StmtSrc | replace "\n" "\n  " }}
    */
    func {{ $stmtName }}(ctx context.Context, e Execer{{ range $args.Args }}, {{ .ArgName }} {{ .ArgType }}{{ end }}) (sql.Result, error) {
      // NOTE: Add a nested block to allow identifier shadowing.
      {
        // Build query.
        query, args, err := nxBuild{{ $stmtName }}Query(map[string]interface{}{
          {{ range $args.Args -}}
            "{{ .ArgName }}": {{ .ArgName }},
          {{ end -}}
        })
        if err != nil {
          return nil, err
        }

        // Execute.
        return e.ExecContext(ctx, query, args...)
      }
    }

  {{ end }} 

  var (
    {{ if $flagUseTemplate -}}
      nx{{ $stmtName }}QueryTmpl = template.Must(template.New("{{ $stmtName }}").Parse({{ printf "%+q" .Text }}))
    {{ else -}}
      nx{{ $stmtName }}Query = {{ printf "%+q" .Text }}
    {{ end -}}
  )

  func nxBuild{{ $stmtName }}Query(data map[string]interface{}) (string, []interface{}, error) {

    {{ if $flagUseTemplate }}
      // Template -> named query.
      buf := bytes.Buffer{}
      if err := nx{{ $stmtName }}QueryTmpl.Execute(&buf, data); err != nil {
        return "", nil, err
      }
      namedQuery := buf.String()
    {{ else }}
      // Named query.
      namedQuery := nx{{ $stmtName }}Query
    {{ end }}

    // Named query -> query.
    query, args, err := sqlx.Named(namedQuery, data)
    if err != nil {
      return "", nil, err
    }

    {{ if $flagInQuery }}
      // Expand "in" args.
      query, args, err = sqlx.In(query, args...)
      if err != nil {
        return "", nil, err
      }
    {{ end }}

    return query, args, nil
  }

{{ end }}

var (
  // Suppress "imported and not used" errors.
  _ = fmt.Printf
  _ = context.Background
  _ = template.IsTrue
  _ = sql.Open
  _ = sqlx.Named
  _ = null.NewBool
  _ = bytes.NewBuffer
  _ = time.Now
)
